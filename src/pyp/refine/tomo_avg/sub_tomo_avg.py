import argparse
import collections
import glob
import os
import shutil
import subprocess
import sys
from xml.etree.ElementTree import parse

import matplotlib.pyplot as plt
import numpy as np

from pyp.inout.image import write_central_slices, write_multiple_slices, writepng
from pyp.system import project_params, slurm, local_run
from pyp.system.logging import initialize_pyp_logger
from pyp.system.singularity import get_pyp_configuration, run_slurm
from pyp.system.utils import get_parameter_files_path
from pyp.utils import get_relative_path

relative_path = str(get_relative_path(__file__))
logger = initialize_pyp_logger(log_name=relative_path)


def run_3davg(parameters):
    # set up xml files to run 3DAVG
    for i in [
        "multiteration_controlled.sh",
        "montage2.sh",
        "montage_classes_filt.pl",
        "filter.xml",
    ]:
        if not os.path.isfile("3DAVG/" + i):
            shutil.copy2(
                "{0}/{1}".format(get_parameter_files_path(), i), "3DAVG",
            )

    if not os.path.isdir("3DAVG/protocol"):

        os.mkdir("3DAVG/protocol")

        for xmlfile in glob.glob("{0}/*.xml".format(get_parameter_files_path())):
            with open(xmlfile, "r") as f:
                contents = f.read().replace("DEFAULT_PATTERN", parameters["data_set"])

            with open("3DAVG/protocol/" + os.path.basename(xmlfile), "w") as f:
                f.write(contents)

        # create flags for automatic sub-volume averaging
        for flag in ["classify", "refine", "mra"]:
            open("3DAVG/" + flag, "a").close()

    config = get_pyp_configuration()
    pyp_location = config["pypLocation"]

    # launch 3DAVG
    command = "cd 3DAVG; {0} {1} --ntasks={5} --exclusive --job-name=3DA_{2} --export PYP_DIR={3},pattern={4},protocol=protocol multiteration_controlled.sh".format(
        run_slurm("sbatch", path=os.path.join(os.getcwd(), "3DAVG")),
        "--partition=" + parameters["slurm_queue"],
        parameters["data_set"][-6:],
        pyp_location,
        parameters["data_set"],
        parameters["slurm_tasks"],
    )  # umask=33
    logger.info(command)

    if int(parameters["class_num"]) > 0:
        logger.info(
            subprocess.check_output(
                command, stderr=subprocess.STDOUT, shell=True, text=True
            )
        )


def plot_slices(dataset, iter, mode, classes):
    """ This function writes out png containing volume slices of all classes generated by 3DAVG for better visualization
    png includes (1) Names of mrc files (2) slices from side views (3) slices from top views
    Args:
        dataset (str): Name of dataset
        iter (int): Current iteration
        mode (int): Current mode 
        classes (int): Number of classes
    """
    # MRC files format examples based on the running mode
    # mode 0 - EMPIAR-10453_global_average_1.mrc
    # mode 1 - EMPIAR-10453_iteration_006_level_10_average_000.mrc
    # mode 2 - EMPIAR-10453_iteration_006_refined_level_10_average_000.mrc
    # mode 3 - EMPIAR-10453_iteration_006_refined_selected_average_0.mrc

    # format names of mrc files depending on the currently running mode, iter ..
    mrcs = "%s_iteration_%03d_" % (dataset, iter)
    if mode == 0:
        mrcs = "%s_global_average_1" % (dataset)
    elif mode == 1:
        mrcs += "level_%d_average_???" % (classes)
    elif mode == 2:
        mrcs += "refined_level_10_average_???"
    elif mode == 3:
        mrcs += "refined_selected_average_0"

    # get the number of available classes/rows
    mrcfiles = sorted(glob.glob(mrcs + ".mrc"))
    num_row = len(mrcfiles)

    if num_row == 0:
        logger.warning("Cannot find any volumes in this iter/mode to plot.")
        sys.exit(1)

    # First, generate montages including slices both from top and side views
    NUM_SIDE_SLICES = 20
    NUM_TOP_SLICES = 20
    fig, axes = plt.subplots(
        figsize=((NUM_SIDE_SLICES + NUM_TOP_SLICES) * 2, num_row * 2),
        nrows=num_row,
        ncols=2,
    )
    # find the mrcs to generate montages
    for c, mrc in enumerate(mrcfiles):
        montages = write_multiple_slices(mrc, NUM_SIDE_SLICES, NUM_TOP_SLICES)
        # make the image contrast better by histogram equal
        side_montage, top_montage = [
            (255.0 * I[::-1, :] - I.min()) / (I.max() - I.min()).astype(np.uint8)
            for I in montages
        ]
        # parse volume slices into subplots
        if num_row == 1:
            axes[0].imshow(side_montage, cmap="gray", aspect="equal")
            axes[0].set_xticks([])
            axes[0].set_yticks([])
            axes[1].imshow(top_montage, cmap="gray", aspect="equal")
            axes[1].set_xticks([])
            axes[1].set_yticks([])
        else:
            axes[c, 0].imshow(side_montage, cmap="gray", aspect="equal")
            axes[c, 0].set_xticks([])
            axes[c, 0].set_yticks([])
            axes[c, 1].imshow(top_montage, cmap="gray", aspect="equal")
            axes[c, 1].set_xticks([])
            axes[c, 1].set_yticks([])

    plt.subplots_adjust(wspace=0, hspace=0)
    plt.savefig("slices.png", bbox_inches="tight")

    # Second, generate png including corresponding filenames
    fig, axes = plt.subplots(figsize=(10 * 2, num_row * 2), nrows=num_row, ncols=1,)
    for c, mrc in enumerate(mrcfiles):
        if num_row == 1:
            axes.set_xlim(0, 1)
            axes.set_ylim(0, 1)
            axes.set_xticks([])
            axes.set_yticks([])
            axes.annotate(
                mrc, xy=(0.5, 0.5), fontsize=30, ha="center", weight="semibold"
            )
        else:
            axes[c].set_xlim(0, 1)
            axes[c].set_ylim(0, 1)
            axes[c].set_xticks([])
            axes[c].set_yticks([])
            axes[c].annotate(
                mrc, xy=(0.5, 0.5), fontsize=30, ha="center", weight="semibold"
            )
    plt.subplots_adjust(wspace=0, hspace=0)
    plt.savefig("mrc_names.png", bbox_inches="tight")

    # contatenate these two pngs (filenams and slices) together
    command = f"montage -geometry +0+0 -tile 2x1 mrc_names.png slices.png { '_'.join(mrcfiles[0].split('_')[:-1])+'.png' }"
    logger.info(
        subprocess.check_output(
            command, stderr=subprocess.STDOUT, shell=True, text=True
        )
    )
    # clean up
    os.remove("mrc_names.png")
    os.remove("slices.png")


def parse_arguments():
    # parse arguments for 3DAVG
    parser = argparse.ArgumentParser(description="3DAVG sub-tomogram averaging")
    parser.add_argument("-dataset", "--dataset", help="Name of dataset", type=str)
    parser.add_argument(
        "-symmetry", "--symmetry", help="Specify symmetry (1)", type=int
    )
    parser.add_argument("-mode", "--mode", help="Mode key 0-3", type=int)
    parser.add_argument(
        "-iter", "--iter", help=" Iteration for refinement (1)", type=int
    )
    parser.add_argument(
        "-mask",
        "--mask",
        help="Elliptical mask defined by x,y,z three parameters (25,25,25)",
        type=str,
    )
    parser.add_argument(
        "-tol_shifts",
        "--tol_shifts",
        help="Tolerance for translational refinemnet in pixel (10)",
        type=int,
    )
    parser.add_argument(
        "-tol_angle",
        "--tol_angle",
        help="Tolerance for rotational refinement (10)",
        type=int,
    )
    parser.add_argument(
        "-zcorr",
        "--zcorr",
        help="Translates volumes and averge in z; postive for up, negative for down (0)",
        type=int,
    )
    parser.add_argument(
        "-classes",
        "--classes",
        help="Number of references for mode 1 classification (5)",
        type=int,
    )
    parser.add_argument(
        "-highpass",
        "--highpass",
        help="High-resolution (cutoff,sigma) for bandpass filter (0.05,0.01)",
        type=str,
    )
    parser.add_argument(
        "-lowpass",
        "--lowpass",
        help="Low-resolution (cutoff,sigma) for bandpass filter (0.25,0.05)",
        type=str,
    )
    parser.add_argument(
        "-cpu", "--cpu", help="Number of CPUs for 3DAVG job (320)", type=int,
    )
    parser.add_argument(
        "-filter_map",
        "--filter_map",
        help="The map in which parameters in the xml is applied for investigation in real time (default is global average)",
        type=str,
    )
    parser.add_argument(
        "-plot",
        "--plot",
        help="Plot slices of classified volumes from 3DAVG. Only use this option after each iteration is done. (e.g. 3davg -plot)",
        action="store_true",
    )
    parser.add_argument(
        "-sq",
        "--slurm_queue",
        help="The partition you wish to use to run your jobs",
        type=str,
    )

    args = parser.parse_args()

    # create empty parameter file
    empty_parameters = collections.OrderedDict(
        [
            (
                "dataset",
                os.path.split(os.path.abspath(os.path.join(os.getcwd(), os.pardir)))[
                    -1
                ],
            )
        ]
    )
    empty_parameters.update(
        [
            ("symmetry", 1),
            ("mode", 0),
            ("iter", 1),
            ("mask", "25,25,25"),
            ("tol_shifts", 10),
            ("tol_angle", 10),
            ("zcorr", 0),
            ("classes", 5),
            ("highpass", "0.05,0.01"),
            ("lowpass", "0.25,0.05"),
            ("cpu", 320),
            ("filter_map", empty_parameters["dataset"] + "_global_average.mrc"),
            ("slurm_queue", '')
        ]
    )

    # load existing parameters
    parameters = project_params.load_3davg_parameters()

    if parameters == 0:
        parameters = empty_parameters
    else:
        if len(parameters) is not len(empty_parameters):
            logger.warning("Paramter file has changed. Adding new entries:")
            for key in list(empty_parameters.keys()):
                if key not in parameters:
                    print("\t", key, empty_parameters[key])
                    parameters[key] = empty_parameters[key]

    for k, v in vars(args).items():
        # plot classes png if -plot option is given in the command
        if k == "plot" and v == True:
            plot_slices(
                parameters["dataset"],
                int(parameters["iter"]),
                int(parameters["mode"]),
                int(parameters["classes"]),
            )
            # normal exit
            sys.exit(0)
        # update user-provided param in config file
        if v != None and k != "plot" and parameters[k] is not v:
            logger.info("Updating {0} from {1} to {2}".format(k, parameters[k], v))
            parameters[k] = v

    # check dataset
    if parameters["dataset"] == 0:
        logger.info("-dataset is required.")
        sys.exit(1)

    project_params.save_3davg_parameters(parameters)

    return parameters


def parse_xml(mp, sp):
    """Parse parameters in xml file required for each iteration/mode of 3DAVG

    Args:
        mp (Dict): Configuration of pyp
        sp (Dict): Configuration of 3DAVG
    """
    xml = "protocol/iteration_%03d_mode_%d.xml" % (int(sp["iter"]), int(sp["mode"]))
    MODE_LIST = ["recenter", "class", "refine", "mra"]

    # parse data in xml reader
    data = parse(xml)
    root = data.getroot()

    # modify general parameters such as volumes size and z correction
    general = root.find("general")
    volsize = general.find("image_geometry").find("volume_size")
    volcutoff = general.find("image_geometry").find("volume_cut_offset")
    volsize.text = str(mp["tomo_ext_size"])
    volcutoff.text = str(sp["zcorr"])

    # modify setting corresponding to the mode
    mode = int(sp["mode"])
    # check mode
    if mode < 0 or mode > 3:
        logger.error(f"Cuurently only support mode 0 - 3.")
        sys.exit(1)
    # mode 0 (re-centering) uses mra field
    if mode == 0:
        mode = 3

    # parse filter, sym, mask parameters in the corresponding field
    mode_field = root.find(MODE_LIST[mode])
    sym_text = MODE_LIST[mode] + "_use_symmetrization"
    window_x_text, window_y_text, window_z_text = [
        MODE_LIST[mode] + t
        for t in ["_image_window_x", "_image_window_y", "_image_window_z"]
    ]
    highcut_text = MODE_LIST[mode] + "_high_pass_cutoff"
    highdecay_text = MODE_LIST[mode] + "_high_pass_decay"
    lowcut_text = MODE_LIST[mode] + "_low_pass_cutoff"
    lowdecay_text = MODE_LIST[mode] + "_low_pass_decay"

    sym = mode_field.find(sym_text)
    x = mode_field.find(window_x_text)
    y = mode_field.find(window_y_text)
    z = mode_field.find(window_z_text)
    highcut = mode_field.find(highcut_text)
    highdecay = mode_field.find(highdecay_text)
    lowcut = mode_field.find(lowcut_text)
    lowdecay = mode_field.find(lowdecay_text)

    sym.text = str(sp["symmetry"])
    # check mask setting
    try:
        window_x, window_y, window_z = [size for size in sp["mask"].split(",")]
        x.text, y.text, z.text = window_x, window_y, window_z
    except ValueError:
        logger.error("Mask should be defined by x,y,z, which is separated by comma.")
        sys.exit(1)

    # check filter setting
    if sp["highpass"] != None and sp["lowpass"] != None:
        try:
            high = sp["highpass"].split(",")
            low = sp["lowpass"].split(",")
            high_cutoff, high_sigma = high
            low_cutoff, low_sigma = low
        except ValueError:
            logger.error(
                "Filter should be defined clearly by cutoff,sigma, which is separated by comma."
            )
            sys.exit(1)

        if high >= low:
            logger.error(
                f"Your low-pass cutoff {low} should be higher than high-pass cutoff {high}"
            )
            sys.exit(1)
        else:
            highcut.text = high_cutoff
            highdecay.text = high_sigma
            lowcut.text = low_cutoff
            lowdecay.text = low_sigma
    else:
        logger.error("Filter setting is required - lowpass and highpass")
        sys.exit(1)

    # modify rot, shifts if mode is refine or mra
    if mode == 2 or mode == 3:
        rot_text = MODE_LIST[mode] + "_out_of_plane_search_range"
        trans_text = MODE_LIST[mode] + "_shifts_tolerance"

        rot = mode_field.find(rot_text)
        trans = mode_field.find(trans_text)
        rot.text = str(sp["tol_angle"])
        trans.text = str(sp["tol_shifts"])

    # modify number of classes if mode == class
    if mode == 1:
        class_text = "class_number_of_classes"
        classification = mode_field.find(class_text)
        classification.text = str(sp["classes"])

    # write out modified xml for actual 3DAVG refinement
    data.write(xml.replace(".xml", ".exe.xml"), encoding="utf-8", xml_declaration=True)


def sva_iterate(mp, sp, iter):
    """Iterate 3DAVG job; mode 0 - recenter; mode 1 - classification;
    mode 2 - refine; mode 3 - mra.

    Args:
        mp (Dict): Parameters for pyp
        sp (Dict): Parameters for 3DAVG
        iter (int): Current iteration of 3DAVG
    """
    mode = int(sp["mode"])
    dataset = str(sp["dataset"])
    xmlexe = "protocol/iteration_%03d_mode_%d.exe.xml" % (iter, mode)
    test_mrc = sp["filter_map"]
    executable = r"${PYP_DIR}/external/TOMO" + "/MPI_Classification"
    test_filter = r"${PYP_DIR}/external/TOMO" + "/Test_Metric_Filter"
    queue = sp["slurm_queue"]

    if iter != 1 and mode == 0:
        logger.error(f"Re-cetering (mode 0) can only be used with iter 1.")
        sys.exit(1)

    # parse parameters into xml needed for running 3DAVG
    parse_xml(mp, sp)

    # remove matlab files and tmp in case re-running using un-modified parameters
    [os.remove(f) for f in glob.glob("./*.matlab")]
    [os.remove(f) for f in glob.glob("./*.tmp")]

    # Apply xml settings to the global average (or other mrcs if a different map is given)
    # and save them as montaged png
    test_command = f"module load FFTW/3.3.7; {test_filter} {xmlexe} -1 {test_mrc}"
    if not os.path.exists(test_mrc):
        logger.error(
            f"{test_mrc} does not exist, please provide a correct volume for Test_Metric_Filter"
        )
    try:
        id = subprocess.check_output(
            test_command, stderr=subprocess.STDOUT, shell=True, text=True
        ).split()[-1]
        logger.info(f"Apply filter on {test_mrc}")

        montage_original = write_central_slices(test_mrc)
        montage_filtered = write_central_slices(test_mrc + ".filtered.mrc")
        writepng(montage_original, test_mrc + ".png")
        writepng(montage_filtered, test_mrc + ".filtered.mrc.png")
        command = f"montage -geometry 600x200 -tile 1x2 {test_mrc+'.png'} {test_mrc+'.filtered.mrc.png'} {test_mrc+'.filtered.png'}"
        logger.info(
            subprocess.check_output(
                command, stderr=subprocess.STDOUT, shell=True, text=True
            )
        )
        # clean up
        os.remove(test_mrc + ".png")
        os.remove(test_mrc + ".filtered.mrc.png")
    except:
        logger.warning("Cannot apply Test_Metric_Filter to test your parameters")

    # prepare sbatch file for slurm job submission
    command_file = f"prepare_3davg.sh"
    if os.path.exists(command_file):
        os.remove(command_file)
    with open(command_file, "w") as f:
        f.write("#!/bin/bash\n")
        f.write("module load MPICH\n")
        f.write("module load FFTW/3.3.7\n")
        f.write(f"{executable} {xmlexe} && 3davg -plot")

    # submit job using slurm
    sbatch_com = f"sbatch --partition={queue} --mem=600g --cpus-per-task=1 --output='swarm/%x_iter{iter}_mode{mode}_%j.out' --error=swarm/%x_iter{iter}_mode{mode}_%j.err --ntasks={sp['cpu']} --job-name=3DAVG {command_file}"
    """
    id = slurm.submit_jobs(
        ".",
        f"{command_file}",
        "3davg_swarm",
        f"3DA_{dataset}",
        queue,
        0,
        sp["cpu"],
        600,
    )
    """
    local_run.run_shell_command(sbatch_com, verbose = True)
    logger.info(
        f"\n\n\n\t\t 3DAVG [ iteration {iter} ] [ mode {mode} ] submitted successfully, JOBID = {id} \n\n"
    )
